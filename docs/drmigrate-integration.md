# Dr. Migrate Integration

This document describes how to generate architecture recommendation context files from Dr. Migrate data sources, enabling architecture recommendations for ALL applications—not just those with Java/.NET App Cat scans.

## Overview

The Architecture Scorer typically requires context files generated by the App Cat (Application Categorizer) process, which only works for applications with Java or .NET components. However, Dr. Migrate exposes a wealth of application and infrastructure data via its LLM-accessible views that can be used to generate compatible context files for any application.

This integration allows you to:
- Generate context files for applications without Java/.NET components
- Leverage existing Dr. Migrate data without additional scanning
- Get architecture recommendations for your entire application portfolio

## Data Source Mapping

The following table shows how Dr. Migrate data sources map to context file fields:

| Context File Section | Dr. Migrate Source | Notes |
|---------------------|-------------------|-------|
| `app_overview` | `Application_Overview` | Direct mapping for most fields |
| `server_details` | `Server_Overview_Current` | Server config and performance |
| `detected_technology_running` | Multiple sources | Combined from tech stack, installed apps, key software |
| `app_approved_azure_services` | Inferred + `Cloud_Server_Cost` | Based on technology and assigned targets |
| `App Mod results` | `App_Modernization_Candidates` | Partial/inferred for non-Java/.NET apps |

### Detailed Field Mappings

#### app_overview
| Context Field | Dr. Migrate Field | Notes |
|--------------|-------------------|-------|
| `application` | `application` | Direct mapping |
| `app_type` | `app_type`, `app_function` | Falls back through available fields |
| `business_crtiticality` | `business_critical`, `inherent_risk`, `materiality` | Derived from multiple indicators |
| `treatment` | `assigned_migration_strategy` | Mapped to 7R strategy |
| `owner` | `app_owner` | Direct mapping |

#### server_details
| Context Field | Dr. Migrate Field | Notes |
|--------------|-------------------|-------|
| `machine` | `machine` | Direct mapping |
| `environment` | `environment` | Direct mapping |
| `OperatingSystem` | `OperatingSystem` | Direct mapping |
| `MemoryGB` | `AllocatedMemoryInGB` | Direct mapping |
| `Cores` | `Cores` | Direct mapping |
| `CPUUsage` | `CPUUsageInPct` | Direct mapping |
| `MemoryUsage` | `MemoryUsageInPct` | Direct mapping |
| `AzureVMReadiness` | `CloudVMReadiness` | Mapped to Ready/ReadyWithConditions/NotReady |
| `detected_COTS` | `Installed_Applications.key_software` | Per-server software |

## CLI Usage

### Generate Context from Dr. Migrate Data

```bash
# Generate context file from Dr. Migrate data
architecture-scorer generate-context -i drmigrate-data.json -o context.json

# Include cost comparison data
architecture-scorer generate-context -i drmigrate-data.json -o context.json --include-costs

# Include network dependency data
architecture-scorer generate-context -i drmigrate-data.json -o context.json --include-network

# Output to stdout (compact JSON)
architecture-scorer generate-context -i drmigrate-data.json --compact
```

### Generate Sample Input File

```bash
# Create a sample Dr. Migrate input file to see the expected format
architecture-scorer generate-sample-drmigrate -o sample.json -n "MyApplication"

# Then generate context from the sample
architecture-scorer generate-context -i sample.json -o context.json

# Score the application
architecture-scorer score -c architecture-catalog.json -x context.json
```

## Input Format

The generator accepts JSON in the following format:

### Single Application

```json
{
  "application_overview": {
    "application": "MyApp",
    "number_of_machines": 3,
    "number_of_environments": 2,
    "environment_names": "Production, Development",
    "complexity_rating": "Medium",
    "app_type": "In-house",
    "app_owner": "IT Department",
    "business_critical": "Yes",
    "high_availability": "Yes",
    "assigned_migration_strategy": "Replatform",
    "other_tech_stack_components": "Java 11, Spring Boot, PostgreSQL"
  },
  "server_overviews": [
    {
      "machine": "APP-WEB-01",
      "application": "MyApp",
      "environment": "Production",
      "OperatingSystem": "Ubuntu 20.04",
      "CloudVMReadiness": "Ready",
      "AllocatedMemoryInGB": 8.0,
      "Cores": 4,
      "CPUUsageInPct": 45.5,
      "StorageGB": 100.0
    }
  ],
  "installed_applications": [
    {
      "machine": "APP-WEB-01",
      "key_software": "Java 11",
      "key_software_category": "Runtime"
    }
  ],
  "key_software": [
    {
      "application": "MyApp",
      "key_software": "Spring Boot"
    }
  ],
  "cloud_server_costs": [
    {
      "machine": "APP-WEB-01",
      "assigned_treatment": "Replatform",
      "assigned_target": "Azure App Service"
    }
  ],
  "app_mod_candidates": [
    {
      "application": "MyApp",
      "app_mod_candidate_technology": "Java"
    }
  ]
}
```

### Multiple Applications

```json
[
  { "application_overview": { "application": "App1", ... }, ... },
  { "application_overview": { "application": "App2", ... }, ... }
]
```

## Programmatic Usage

### Python API

```python
from architecture_scorer.drmigrate_generator import DrMigrateContextGenerator
from architecture_scorer.drmigrate_schema import (
    DrMigrateApplicationData,
    DrMigrateApplicationOverview,
    DrMigrateServerOverview,
)

# Create application data
app_data = DrMigrateApplicationData(
    application_overview=DrMigrateApplicationOverview(
        application="MyApp",
        business_critical="Yes",
        assigned_migration_strategy="Replatform",
        other_tech_stack_components="Java 11, Spring Boot",
    ),
    server_overviews=[
        DrMigrateServerOverview(
            machine="APP-WEB-01",
            environment="Production",
            OperatingSystem="Ubuntu 20.04",
            CloudVMReadiness="Ready",
        )
    ],
)

# Generate context
generator = DrMigrateContextGenerator(
    include_cost_data=True,
    include_network_data=False,
)
context = generator.generate_context(app_data)

# Output as JSON
json_str = generator.generate_context_json(app_data, indent=2)

# Batch processing
apps = [app_data1, app_data2, app_data3]
results = generator.generate_batch_contexts(apps)
```

### Custom Azure Service Mappings

```python
custom_mappings = {
    "Custom Database": "Azure SQL Database",
    "Legacy Middleware": "Azure Kubernetes Service",
}

generator = DrMigrateContextGenerator(
    azure_service_mappings=custom_mappings
)
```

## Limitations

When generating context files from Dr. Migrate data instead of App Cat scans:

1. **App Mod Results**: The `App Mod results` section will contain inferred/partial data rather than detailed App Cat scan results. This includes:
   - Platform compatibility is inferred from technology type
   - No detailed code-level findings
   - Blockers are not detected (only infrastructure-level issues)

2. **Technology Detection**: Technology detection relies on:
   - `other_tech_stack_components` field
   - `Installed_Applications` data
   - Operating system information

   This may miss some technologies that would be detected by App Cat scanning.

3. **Compatibility Assessment**: Without App Cat scans, compatibility with Azure services is inferred based on general technology patterns rather than code analysis.

## Best Practices

1. **Use App Cat When Available**: For Java and .NET applications, prefer using App Cat scans when possible for more accurate results.

2. **Enrich Technology Data**: Ensure the `other_tech_stack_components` and installed applications data in Dr. Migrate is as complete as possible.

3. **Review Inferred Results**: Context files generated from Dr. Migrate data will include a `_generated_from: dr_migrate` marker and inferred App Mod results will have `inferred_from_dr_migrate: true` in the summary.

4. **Answer Clarification Questions**: Since some data may be incomplete, be prepared to answer more clarification questions during the scoring process.

## Troubleshooting

### Missing Technologies

If technologies aren't being detected:
- Verify `other_tech_stack_components` contains comma-separated technology names
- Check that `installed_applications` data is populated for each server
- Ensure OS information is present in `server_overviews`

### Incorrect Treatment Mapping

The generator maps common strategy names:
- "Lift and Shift" → Rehost
- "Rearchitect" → Refactor
- "Repurchase" → Replace

If your strategy names differ, the original value will be used as-is.

### VM Readiness Issues

VM readiness is mapped from `CloudVMReadiness`:
- "Ready" → Ready
- "Ready with conditions" → ReadyWithConditions
- "Not Ready" / "NotReady" → NotReady
- Other values → Unknown
